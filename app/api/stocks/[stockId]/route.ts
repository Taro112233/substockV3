// üìÑ File: app/api/stocks/[stockId]/route.ts (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö enum ‡πÉ‡∏´‡∏°‡πà)

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { verifyToken } from '@/lib/auth'
import { z } from 'zod'

// Schema ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö validation
const updateStockSchema = z.object({
  totalQuantity: z.number().min(0, '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 0'),
  minimumStock: z.number().min(0, '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ 0'),
  adjustmentReason: z.string().min(1, '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•'),
  department: z.enum(['PHARMACY', 'OPD'])
})

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≥‡∏´‡∏ô‡∏î TransactionType ‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
const determineTransactionType = (
  quantityChange: number,
  minimumStockChange: number,
  reason: string
): string => {
  // ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏à‡∏£‡∏¥‡∏á
  if (quantityChange !== 0) {
    if (quantityChange > 0) return 'ADJUST_INCREASE'
    if (quantityChange < 0) return 'ADJUST_DECREASE'
  }
  
  // ‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô minimum stock ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
  if (quantityChange === 0 && minimumStockChange !== 0) {
    if (minimumStockChange > 0) return 'MIN_STOCK_INCREASE'
    if (minimumStockChange < 0) return 'MIN_STOCK_DECREASE'
  }
  
  // ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏≠‡∏∞‡πÑ‡∏£‡πÄ‡∏•‡∏¢
  return 'DATA_UPDATE'
}

// ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
const generateAdjustmentReason = (
  currentQty: number, 
  newQty: number, 
  currentMin: number, 
  newMin: number
): string => {
  const qtyChange = newQty - currentQty
  const minChange = newMin - currentMin

  if (qtyChange === 0) {
    if (minChange === 0) return '‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'
    if (minChange > 0) return '‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥'
    if (minChange < 0) return '‡∏õ‡∏£‡∏±‡∏ö‡∏•‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥'
  }
  
  if (qtyChange > 0) return '‡∏õ‡∏£‡∏±‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ï‡πá‡∏≠‡∏Å'
  if (qtyChange < 0) return '‡∏õ‡∏£‡∏±‡∏ö‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å'

  return '‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•'
}

interface RouteContext {
  params: Promise<{ stockId: string }>
}

export async function GET(request: NextRequest, context: RouteContext) {
  try {
    const { stockId } = await context.params

    const token = request.headers.get('authorization')?.replace('Bearer ', '') || 
                  request.cookies.get('auth-token')?.value;
    
    if (!token) {
      return NextResponse.json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö token ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö' }, { status: 401 })
    }

    const decoded = await verifyToken(token)
    if (!decoded) {
      return NextResponse.json({ error: 'Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' }, { status: 401 })
    }

    const stock = await prisma.stock.findUnique({
      where: { id: stockId },
      include: {
        drug: {
          select: {
            hospitalDrugCode: true,
            name: true,
            genericName: true,
            dosageForm: true,
            strength: true,
            unit: true,
            packageSize: true,
            category: true,
            pricePerBox: true,
            notes: true
          }
        },
        transactions: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          include: {
            user: {
              select: { 
                firstName: true,
                lastName: true 
              }
            }
          }
        }
      }
    })

    if (!stock) {
      return NextResponse.json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å' }, { status: 404 })
    }

    return NextResponse.json({
      success: true,
      data: stock
    })

  } catch (error: any) {
    console.error('Get stock error:', error)
    return NextResponse.json(
      { error: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å' },
      { status: 500 }
    )
  }
}

// ‚úÖ PATCH - ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö enum ‡πÉ‡∏´‡∏°‡πà)
export async function PATCH(request: NextRequest, context: RouteContext) {
  try {
    const { stockId } = await context.params

    const token = request.headers.get('authorization')?.replace('Bearer ', '') || 
                  request.cookies.get('auth-token')?.value;
    
    if (!token) {
      return NextResponse.json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö token ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö' }, { status: 401 })
    }

    const decoded = await verifyToken(token)
    if (!decoded) {
      return NextResponse.json({ error: 'Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' }, { status: 401 })
    }

    const body = await request.json()

    // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô
    const currentStock = await prisma.stock.findUnique({
      where: { id: stockId },
      include: { drug: true }
    })

    if (!currentStock) {
      return NextResponse.json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å' }, { status: 404 })
    }

    // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ
    if (!body.adjustmentReason || !body.adjustmentReason.trim()) {
      body.adjustmentReason = generateAdjustmentReason(
        currentStock.totalQuantity,
        body.totalQuantity || currentStock.totalQuantity,
        currentStock.minimumStock,
        body.minimumStock || currentStock.minimumStock
      )
    }

    const validatedData = updateStockSchema.parse(body)
    const { totalQuantity, minimumStock, adjustmentReason, department } = validatedData

    if (currentStock.department !== department) {
      return NextResponse.json({ error: '‡πÅ‡∏ú‡∏ô‡∏Å‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö' }, { status: 400 })
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
    const quantityChange = totalQuantity - currentStock.totalQuantity
    const minimumStockChange = minimumStock - currentStock.minimumStock

    // ‚úÖ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î TransactionType ‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
    const transactionType = determineTransactionType(quantityChange, minimumStockChange, adjustmentReason)

    const result = await prisma.$transaction(async (tx) => {
      // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å
      const updatedStock = await tx.stock.update({
        where: { id: stockId },
        data: {
          totalQuantity,
          minimumStock,
          lastUpdated: new Date(),
          ...(quantityChange !== 0 && {
            totalValue: (currentStock.totalValue / Math.max(currentStock.totalQuantity, 1)) * totalQuantity
          })
        },
        include: {
          drug: {
            select: {
              hospitalDrugCode: true,
              name: true,
              genericName: true,
              dosageForm: true,
              strength: true,
              unit: true,
              packageSize: true,
              category: true,
              pricePerBox: true,
              notes: true
            }
          }
        }
      })

      // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á transaction record ‡∏ï‡∏≤‡∏° enum ‡πÉ‡∏´‡∏°‡πà
      let transactionNote = adjustmentReason
      let recordQuantity = 0

      // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö transaction record
      switch (transactionType) {
        case 'ADJUST_INCREASE':
        case 'ADJUST_DECREASE':
          recordQuantity = Math.abs(quantityChange)
          break
        case 'MIN_STOCK_INCREASE':
          recordQuantity = minimumStockChange
          transactionNote = `‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏à‡∏≤‡∏Å ${currentStock.minimumStock} ‡πÄ‡∏õ‡πá‡∏ô ${minimumStock}`
          break
        case 'MIN_STOCK_DECREASE':
          recordQuantity = Math.abs(minimumStockChange)
          transactionNote = `‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏à‡∏≤‡∏Å ${currentStock.minimumStock} ‡πÄ‡∏õ‡πá‡∏ô ${minimumStock}`
          break
        case 'DATA_UPDATE':
          recordQuantity = 0
          transactionNote = '‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ'
          break
      }

      // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å transaction log (‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° audit trail)
      await tx.stockTransaction.create({
        data: {
          stockId: currentStock.id,
          userId: decoded.userId,
          type: transactionType,
          quantity: recordQuantity,
          beforeQty: currentStock.totalQuantity,
          afterQty: totalQuantity,
          unitCost: currentStock.totalValue / Math.max(currentStock.totalQuantity, 1),
          totalCost: recordQuantity * (currentStock.totalValue / Math.max(currentStock.totalQuantity, 1)),
          reference: `${transactionType}_${Date.now()}`,
          note: transactionNote
        }
      })

      return updatedStock
    })

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö
    let message = '‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
    
    switch (transactionType) {
      case 'ADJUST_INCREASE':
        message = `‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏ï‡πá‡∏≠‡∏Å ${quantityChange} ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`
        break
      case 'ADJUST_DECREASE':
        message = `‡∏•‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å ${Math.abs(quantityChange)} ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`
        break
      case 'MIN_STOCK_INCREASE':
        message = `‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÄ‡∏õ‡πá‡∏ô ${minimumStock} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`
        break
      case 'MIN_STOCK_DECREASE':
        message = `‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÄ‡∏õ‡πá‡∏ô ${minimumStock} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`
        break
      case 'DATA_UPDATE':
        message = '‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'
        break
    }

    return NextResponse.json({
      success: true,
      data: {
        ...result,
        lastUpdated: result.lastUpdated.toISOString()
      },
      message,
      transactionInfo: {
        type: transactionType,
        quantityChanged: quantityChange !== 0,
        quantityChange,
        minimumStockChanged: minimumStockChange !== 0,
        minimumStockChange,
        reason: adjustmentReason
      }
    })

  } catch (error: any) {
    console.error('Update stock error:', error)
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { 
          error: '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á',
          details: error.issues.map((issue) => issue.message).join(', ')
        },
        { status: 400 }
      )
    }

    return NextResponse.json(
      { error: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å' },
      { status: 500 }
    )
  }
}

export async function DELETE(request: NextRequest, context: RouteContext) {
  try {
    const { stockId } = await context.params

    const token = request.headers.get('authorization')?.replace('Bearer ', '') || 
                  request.cookies.get('auth-token')?.value;
    
    if (!token) {
      return NextResponse.json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö token ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö' }, { status: 401 })
    }

    const decoded = await verifyToken(token)
    if (!decoded) {
      return NextResponse.json({ error: 'Token ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á' }, { status: 401 })
    }

    const existingStock = await prisma.stock.findUnique({
      where: { id: stockId },
      include: { 
        drug: { select: { name: true } },
        transactions: { take: 1 }
      }
    })

    if (!existingStock) {
      return NextResponse.json({ error: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å' }, { status: 404 })
    }

    if (existingStock.transactions.length > 0) {
      return NextResponse.json({ 
        error: '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏î‡πâ ‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏≤‡∏Å‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡πÅ‡∏•‡πâ‡∏ß' 
      }, { status: 400 })
    }

    await prisma.stock.delete({
      where: { id: stockId }
    })

    return NextResponse.json({
      success: true,
      message: `‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏¢‡∏≤ "${existingStock.drug.name}" ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à`
    })

  } catch (error: any) {
    console.error('Delete stock error:', error)
    return NextResponse.json(
      { error: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏ï‡πá‡∏≠‡∏Å' },
      { status: 500 }
    )
  }
}